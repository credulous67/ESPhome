# -----------------------------------------------------------------------------
# PROJECT: Dual-Zone OpenTherm S-Plan Controller
# DEVICE: ESP32 NodeMCU / Wemos D1 Mini ESP32
# DESCRIPTION: PID modulated heating with logic interlocks for external valves.
# -----------------------------------------------------------------------------

substitutions:
  devicename: "central-heating-controller"
  friendly_name: "Heating Logic Board"
  # Boiler Limits
  max_flow_temp: "70.0"   # Maximum water temp the boiler is allowed to output
  min_flow_temp: "30.0"   # Minimum effective temp (below this, efficiency gains diminish or boiler cycles)
  # PID Thresholds
  pid_deadband: "0.05"    # 5% demand required to open valves (prevents micro-firing)

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}

esp32:
  board: wemos_d1_mini32
  framework:
    type: arduino

# -----------------------------------------------------------------------------
# LOGGING & DEBUGGING
# -----------------------------------------------------------------------------
logger:
  level: DEBUG
  baud_rate: 115200
  logs:
    esp32_ble_tracker: WARN
    sensor: INFO
    binary_sensor: INFO
    opentherm: INFO
    pvvx_mithermometer: INFO

# -----------------------------------------------------------------------------
# CONNECTIVITY
# -----------------------------------------------------------------------------
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret fb_hotspot_ssid_D1mini_opentherm
    password: !secret fb_hotspot_pw_D1mini_opentherm

# Home Assistant API
api:
  encryption:
    key: !secret HAapikey_D1mini_opentherm

ota:
  - platform: esphome
    password: !secret otapw_D1mini_opentherm

# -----------------------------------------------------------------------------
# HARDWARE: OPENTHERM
# -----------------------------------------------------------------------------
opentherm:
  in_pin: 21   # ESP32 RX <- Shield OUT
  out_pin: 22  # ESP32 TX -> Shield IN
  id: ot_hub

# We must define these entities so we can control them from lambdas/scripts
number:
  - platform: opentherm
    t_set:
      id: ot_t_set
      name: "Boiler Control Setpoint"
      min_value: 0
      max_value: 90
      step: 1

switch:
  - platform: opentherm
    ch_enable:
      id: ot_ch_enable
      name: "Boiler CH Enabled"

# -----------------------------------------------------------------------------
# HARDWARE: BLUETOOTH SENSORS (XIAOMI PVVX)
# -----------------------------------------------------------------------------
esp32_ble_tracker:
  scan_parameters:
    interval: 300ms
    window: 200ms

sensor:
  # ---------------------------------------------------------------------------
  # Temperature Inputs
  # ---------------------------------------------------------------------------
  - platform: pvvx_mithermometer
    mac_address: "A4:C1:38:AA:DC:57"  # <--- UPDATE THIS REAL MAC
    temperature:
      name: "Downstairs Room Temp"
      id: temp_downstairs
    humidity:
      name: "Downstairs Humidity"
    battery_level:
      name: "Downstairs Battery"

  - platform: pvvx_mithermometer
    mac_address: "A4:C1:38:57:0F:22"  # <--- UPDATE THIS REAL MAC
    temperature:
      name: "Upstairs Room Temp"
      id: temp_upstairs
    humidity:
      name: "Upstairs Humidity"
    battery_level:
      name: "Upstairs Battery"

  # ---------------------------------------------------------------------------
  # Boiler Feedback Sensors (OpenTherm)
  # ---------------------------------------------------------------------------
  - platform: opentherm
    t_boiler:
      name: "Boiler Flow Temperature"
      id: boiler_actual_flow
    t_ret:
      name: "Boiler Return Temperature"
    rel_mod_level:
      name: "Boiler Modulation"
      id: boiler_mod_level
    ch_pressure:
      name: "System Pressure"
    # NEW: DHW Temperature Sensor
    t_dhw:
      name: "DHW Temperature"
      id: dhw_temp
    t_dhw2:
      name: "DHW2 Temperature"
      id: dhw2_temp
    dhw_flow_rate:
      name: "DHW flow rate"
      id: dhw_flow

# -----------------------------------------------------------------------------
# INPUTS: VALVE STATUS FROM HOME ASSISTANT
# -----------------------------------------------------------------------------
binary_sensor:
  - platform: homeassistant
    name: "Valve Downstairs End-Stop"
    entity_id: binary_sensor.kincody_valve_valve_downstairs_open
    id: valve_fb_downstairs
  
  - platform: homeassistant
    name: "Valve Upstairs End-Stop"
    entity_id: binary_sensor.kincody_valve_valve_upstairs_open
    id: valve_fb_upstairs

  # Boiler Status
  - platform: opentherm
    flame_on:
      name: "Flame Status"
    fault_indication:
      name: "Fault Status"
    # NEW: DHW Active Status
    dhw_active:
      name: "DHW Active"
      id: dhw_active_state

# -----------------------------------------------------------------------------
# LOGIC STORE: GLOBAL VARIABLES
# -----------------------------------------------------------------------------
globals:
  - id: pid_out_downstairs
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: pid_out_upstairs
    type: float
    restore_value: no
    initial_value: '0.0'

# -----------------------------------------------------------------------------
# CLIMATE CONTROLLERS (PID)
# -----------------------------------------------------------------------------
climate:
  # Downstairs Controller
  - platform: pid
    name: "Downstairs Thermostat"
    id: cli_down
    sensor: temp_downstairs
    default_target_temperature: 20
    heat_output: out_pid_down
    control_parameters:
      kp: 0.3
      ki: 0.004
      kd: 0
    visual:
      min_temperature: 10
      max_temperature: 25
      temperature_step: 0.1

  # Upstairs Controller
  - platform: pid
    name: "Upstairs Thermostat"
    id: cli_up
    sensor: temp_upstairs
    default_target_temperature: 19
    heat_output: out_pid_up
    control_parameters:
      kp: 0.3
      ki: 0.004
      kd: 0
    visual:
      min_temperature: 10
      max_temperature: 25
      temperature_step: 0.1

# -----------------------------------------------------------------------------
# OUTPUT INTERCEPTION (The Logic Layer)
# -----------------------------------------------------------------------------
output:
  - platform: template
    id: out_pid_down
    type: float
    write_action:
      - lambda: |-
          id(pid_out_downstairs) = state;
      - if:
          condition:
            lambda: 'return state > ${pid_deadband};'
          then:
            - homeassistant.service:
                service: switch.turn_on
                data:
                  entity_id: switch.kincody_valve_relay_downstairs
          else:
            - homeassistant.service:
                service: switch.turn_off
                data:
                  entity_id: switch.kincody_valve_relay_downstairs
      - script.execute: arbitrate_boiler_demand

  - platform: template
    id: out_pid_up
    type: float
    write_action:
      - lambda: |-
          id(pid_out_upstairs) = state;
      - if:
          condition:
            lambda: 'return state > ${pid_deadband};'
          then:
            - homeassistant.service:
                service: switch.turn_on
                data:
                  entity_id: switch.kincody_valve_relay_upstairs
          else:
            - homeassistant.service:
                service: switch.turn_off
                data:
                  entity_id: switch.kincody_valve_relay_upstairs
      - script.execute: arbitrate_boiler_demand

# -----------------------------------------------------------------------------
# MASTER ARBITRATION SCRIPT (The Interlock)
# -----------------------------------------------------------------------------
script:
  - id: arbitrate_boiler_demand
    mode: restart
    then:
      - lambda: |-
          // 1. Fetch Configuration & State
          float max_t = ${max_flow_temp};
          float min_t = ${min_flow_temp};
          float deadband = ${pid_deadband};
          
          float d_req = id(pid_out_downstairs);
          float u_req = id(pid_out_upstairs);
          
          bool d_open = id(valve_fb_downstairs).state;
          bool u_open = id(valve_fb_upstairs).state;
          
          // Debug Header
          ESP_LOGD("logic", "=== HEATING LOGIC CYCLE (SCALED) ===");
          
          // 2. Define the Scaling Helper Function
          // Maps PID (deadband -> 1.0) to (MinTemp -> MaxTemp)
          auto calculate_setpoint = [&](float pid_val) -> float {
            if (pid_val <= deadband) return 0.0;
            
            // Normalize the PID value so 0.05 becomes 0.0, and 1.0 remains 1.0
            float normalized_pid = (pid_val - deadband) / (1.0 - deadband);
            
            // Scale to the boiler's range
            return min_t + (normalized_pid * (max_t - min_t));
          };

          // 3. Calculate Temperature Requirement per Zone
          float d_target_temp = 0.0;
          float u_target_temp = 0.0;
          
          if (d_req > deadband) {
            if (d_open) {
              d_target_temp = calculate_setpoint(d_req);
              ESP_LOGI("logic", ">> Down Demand %.1f%% -> Req %.1f C", d_req*100.0, d_target_temp);
            } else {
              ESP_LOGW("logic", ">> Down WAITING: Valve Closed");
            }
          }
          
          if (u_req > deadband) {
            if (u_open) {
              u_target_temp = calculate_setpoint(u_req);
              ESP_LOGI("logic", ">> Up   Demand %.1f%% -> Req %.1f C", u_req*100.0, u_target_temp);
            } else {
              ESP_LOGW("logic", ">> Up   WAITING: Valve Closed");
            }
          }
          
          // 4. Aggregate Demand (MAX Operator)
          float final_setpoint = std::max(d_target_temp, u_target_temp);
          
          // 5. Final Safety Clamp (Just in case math drifts slightly below min_t)
          if (final_setpoint > 0 && final_setpoint < min_t) {
             final_setpoint = min_t;
          }

          // 6. Execute OpenTherm Command
          ESP_LOGI("logic", ">>> FINAL SETPOINT: %.1f C", final_setpoint);
          
          auto call = id(ot_t_set).make_call();
          call.set_value(final_setpoint);
          call.perform();

          // 7. Explicit CH Enable via Switch Entity
          if (final_setpoint > 0) {
            if (!id(ot_ch_enable).state) {
               id(ot_ch_enable).turn_on();
            }
          } else {
            if (id(ot_ch_enable).state) {
               id(ot_ch_enable).turn_off();
            }
          }

