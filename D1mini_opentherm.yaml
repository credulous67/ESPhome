# -----------------------------------------------------------------------------
# PROJECT: Dual-Zone OpenTherm S-Plan Controller
# DEVICE: ESP32 NodeMCU / Wemos D1 Mini ESP32
# DESCRIPTION: PID modulated heating with logic interlocks for external valves.
# -----------------------------------------------------------------------------

substitutions:
  devicename: "central-heating-controller"
  friendly_name: "Heating Logic Board"
  # Boiler Limits
  max_flow_temp: "70.0"   # Maximum water temp the boiler is allowed to output
  min_flow_temp: "30.0"   # Minimum effective temp (below this, efficiency gains diminish or boiler cycles)
  # Harvest thresholds
  harvest_cutoff: "35.0"    # Stop pumping when water is below this
  standby_setpoint: "10.0"  # Temp to request during harvest
  # PID Thresholds
  pid_deadband: "0.05"    # 5% demand required to open valves (prevents micro-firing)

esphome:
  name: ${devicename}
  friendly_name: ${friendly_name}

esp32:
  board: wemos_d1_mini32
  framework:
    type: arduino

# -----------------------------------------------------------------------------
# LOGGING & DEBUGGING
# -----------------------------------------------------------------------------
logger:
  level: DEBUG
  baud_rate: 115200
  logs:
    esp32_ble_tracker: WARN
    sensor: INFO
    binary_sensor: INFO
    opentherm: INFO
    pvvx_mithermometer: INFO

# -----------------------------------------------------------------------------
# CONNECTIVITY
# -----------------------------------------------------------------------------
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  ap:
    ssid: !secret fb_hotspot_ssid_D1mini_opentherm
    password: !secret fb_hotspot_pw_D1mini_opentherm

# Home Assistant API
api:
  encryption:
    key: !secret HAapikey_D1mini_opentherm
  id: api_server
  homeassistant_services: true

ota:
  - platform: esphome
    password: !secret otapw_D1mini_opentherm

# -----------------------------------------------------------------------------
# HARDWARE: OPENTHERM
# -----------------------------------------------------------------------------
opentherm:
  in_pin: 21   # ESP32 RX <- Shield OUT
  out_pin: 22  # ESP32 TX -> Shield IN
  id: ot_hub

# We must define these entities so we can control them from lambdas/scripts
number:
  - platform: opentherm
    t_set:
      id: ot_t_set
      name: "Boiler Control Setpoint"
      min_value: 0
      max_value: 80
      step: 0.1

switch:
  - platform: opentherm
    ch_enable:
      id: ot_ch_enable
      name: "Boiler CH Enabled"

# -----------------------------------------------------------------------------
# HARDWARE: BLUETOOTH SENSORS (XIAOMI PVVX)
# -----------------------------------------------------------------------------
esp32_ble_tracker:
  scan_parameters:
    interval: 300ms
    window: 200ms

sensor:
  # ---------------------------------------------------------------------------
  # Temperature Inputs
  # ---------------------------------------------------------------------------
  - platform: pvvx_mithermometer
    mac_address: "A4:C1:38:AA:DC:57"  # <--- UPDATE THIS REAL MAC
    temperature:
      name: "Downstairs Room Temp"
      id: temp_downstairs
    humidity:
      name: "Downstairs Humidity"
    battery_level:
      name: "Downstairs Battery"

  - platform: pvvx_mithermometer
    mac_address: "A4:C1:38:57:0F:22"  # <--- UPDATE THIS REAL MAC
    temperature:
      name: "Upstairs Room Temp"
      id: temp_upstairs
    humidity:
      name: "Upstairs Humidity"
    battery_level:
      name: "Upstairs Battery"

  # ---------------------------------------------------------------------------
  # Boiler Feedback Sensors (OpenTherm)
  # ---------------------------------------------------------------------------
  - platform: opentherm
    t_boiler:
      name: "Boiler Flow Temperature"
      id: boiler_flow_temp
      # Trigger logic update on every temp change for responsiveness
      on_value:
        then:
          - script.execute: logic_engine
    t_ret:
      name: "Boiler Return Temperature"
    rel_mod_level:
      name: "Boiler Modulation"
      id: boiler_mod_level
    ch_pressure:
      name: "System Pressure"
    # NEW: DHW Temperature Sensor
    # t_dhw - does not populate from Ideal Logic boiler
    # t_dhw2 - does not populate from Ideal Logic boiler
    dhw_flow_rate:
      name: "DHW flow rate"
      id: dhw_flow
  - platform: template
    name: "heating state raw"
    id: heating_state
    update_interval: 2s
    accuracy_decimals: 0


# -----------------------------------------------------------------------------
# INPUTS: VALVE STATUS FROM HOME ASSISTANT
# -----------------------------------------------------------------------------
binary_sensor:
  - platform: homeassistant
    name: "Valve Downstairs End-Stop"
    entity_id: binary_sensor.kincody_valve_valve_downstairs_open
    id: limit_sw_down
    filters:
      - delayed_on: 100ms
    on_state:
      then:
        - script.execute: logic_engine
  
  - platform: homeassistant
    name: "Valve Upstairs End-Stop"
    entity_id: binary_sensor.kincody_valve_valve_upstairs_open
    id: limit_sw_up
    filters:
      - delayed_on: 100ms
    on_state:
      then:
        - script.execute: logic_engine

  # Boiler Status
  - platform: opentherm
    flame_on:
      name: "Flame Status"
    fault_indication:
      name: "Fault Status"
    # NEW: DHW Active Status
    dhw_active:
      name: "DHW Active"
      id: dhw_active_state

  # Separate outputs for independent zone control
  - platform: template
    id: valve_demand_up
    name: "Valve Demand Upstairs"
    device_class: opening

  - platform: template
    id: valve_demand_down
    name: "Valve Demand Downstairs"
    device_class: opening

# -----------------------------------------------------------------------------
# LOGIC STORE: GLOBAL VARIABLES
# -----------------------------------------------------------------------------
globals:
  - id: pid_out_downstairs
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: pid_out_upstairs
    type: float
    restore_value: no
    initial_value: '0.0'
  - id: demand_up
    type: float
    initial_value: '0.0'
  - id: demand_down
    type: float
    initial_value: '0.0'
  - id: system_state
    type: int 
    initial_value: '0' # 0=Idle, 1=Heating(valve wait), 2=Heating, 3=Harvest(valve wait), 4=Harvest


# -----------------------------------------------------------------------------
# CLIMATE CONTROLLERS (PID)
# -----------------------------------------------------------------------------
climate:
  # Downstairs Controller
  - platform: pid
    name: "Downstairs Thermostat"
    id: cli_down
    sensor: temp_downstairs
    default_target_temperature: 20
    heat_output: out_pid_down
    control_parameters:
      kp: 0.1
      ki: 0.004
      kd: 0
    visual:
      min_temperature: 10
      max_temperature: 25
      temperature_step: 0.1

  # Upstairs Controller
  - platform: pid
    name: "Upstairs Thermostat"
    id: cli_up
    sensor: temp_upstairs
    default_target_temperature: 19
    heat_output: out_pid_up
    control_parameters:
      kp: 0.1
      ki: 0.004
      kd: 0
    visual:
      min_temperature: 10
      max_temperature: 25
      temperature_step: 0.1

# -----------------------------------------------------------------------------
# OUTPUT INTERCEPTION (The Logic Layer)
# -----------------------------------------------------------------------------
output:
  - platform: template
    id: out_pid_down
    type: float
    write_action:
      - globals.set:
          id: demand_down
          value: !lambda 'return state;'
      - script.execute: logic_engine

  - platform: template
    id: out_pid_up
    type: float
    write_action:
      - globals.set:
          id: demand_up
          value: !lambda 'return state;'
      - script.execute: logic_engine

# -----------------------------------------------------------------------------
# LOGIC CORE
# -----------------------------------------------------------------------------
script:
  - id: logic_engine
    mode: QUEUED
    then:
      - lambda: |-
          // 1. GATHER INPUTS
          float d_up = id(demand_up);
          float d_down = id(demand_down);
          float flow_temp = id(boiler_flow_temp).state;

          // Saftety Inputs: Check if valves are ACTUALLY open
          bool sw_up = id(limit_sw_up).state;
          bool sw_down = id(limit_sw_down).state;
          // Global safety condition: At least one valve is open
          bool valves_verified = (sw_up || sw_down);

          float max_t = ${max_flow_temp};
          float min_t = ${min_flow_temp};
          float deadband = ${pid_deadband};
          float harvest_lim = ${harvest_cutoff};
          float standby  = ${standby_setpoint};
          
          // 2. DETERMINE HEAT DEMAND
          bool need_up = (d_up > deadband);
          bool need_down = (d_down > deadband);
          bool any_demand = (need_up || need_down);
          ESP_LOGI("logic", "***START*** UP demand: %s DOWN demand: %s ANY demand: %s   **UP=%.2f** **DOWN=%.2f**", need_up ? "TRUE" : "FALSE", need_down ? "TRUE" : "FALSE", any_demand ? "TRUE" : "FALSE", d_up, d_down);

          // -------------------------------------------------------
          // STATE 1: ACTIVE HEATING
          // -------------------------------------------------------
          if (any_demand) {
            
            // A. Actuate Valves
            // ensure valve limit switch and demand for valves are not out of step
            if (sw_up == need_up) {
              id(valve_demand_up).publish_state(need_up);
            } else {
              id(valve_demand_up).publish_state(false);
              id(valve_demand_up).publish_state(need_up);
            }

            if (sw_down == need_down) {
              id(valve_demand_down).publish_state(need_down);
            } else {
              id(valve_demand_down).publish_state(false);
              id(valve_demand_down).publish_state(need_down);
            }
            
            // B. Safety check & enable boiler
            if (valves_verified) {
              id(system_state) = 2;
              float max_d = std::max(d_up, d_down);
              // Map 0-100% demand to 35-70C flow temp
              float target = min_t + (max_d * (max_t - min_t)); 
              
              id(ot_ch_enable).turn_on();
              id(ot_t_set).make_call().set_value(target).perform();
              
              ESP_LOGD("logic", "HEATING: Demand %.2f%, Target %.2f C", max_d*100.0, target);
            } else {
              id(system_state) = 1;
              // Demand exists, but valves aren't open yet.
              // Wait for limit switch interrupt to re-trigger this script.
              id(ot_ch_enable).turn_off();
              id(ot_t_set).make_call().set_value(0.0).perform();
              ESP_LOGW("logic", "HEATING DELAY: Waiting for limit switches...");
            }
          }
          
          // -------------------------------------------------------
          // STATE 2: HARVEST / OVERRUN
          // -------------------------------------------------------
          else if (flow_temp > harvest_lim) {
            
            // A. Valve Strategy: OPEN BOTH
            id(valve_demand_up).publish_state(true);
            id(valve_demand_down).publish_state(true);
            
            // B. Safety Check & Harvest Enable
            if (valves_verified) {
              id(system_state) = 4;
              // Keep CH Enable TRUE to power the pump.
              id(ot_ch_enable).turn_on();

              // Request low temp. Boiler sees Flow > 10C, so Burner=OFF, Pump=ON.
              id(ot_t_set).make_call().set_value(standby).perform();
              ESP_LOGD("logic", "HARVEST: Flow %.2f > %.2f. Recovering heat.", flow_temp, harvest_lim);
            } else {
              id(system_state) = 3;
              // Valves should be opening, but aren't there yet.
              id(ot_ch_enable).turn_off();
              ESP_LOGW("logic", "HARVEST DELAY: Waiting for limit switches...");
            }
          }
          
          // -------------------------------------------------------
          // STATE 3: IDLE
          // -------------------------------------------------------
          else {
            id(system_state) = 0;
            
            // Shut down everything
            id(valve_demand_up).publish_state(false);
            id(valve_demand_down).publish_state(false);
            id(ot_ch_enable).turn_off();
            id(ot_t_set).make_call().set_value(0.0).perform();
            
            ESP_LOGD("logic", "IDLE: System resting.");
          }
          id(heating_state).publish_state(id(system_state));
          ESP_LOGI("logic", "***FINISH*** heating state: %d", id(system_state));
